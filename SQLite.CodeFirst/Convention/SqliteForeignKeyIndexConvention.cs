using SQLite.CodeFirst.Extensions;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Annotations;
using System.Data.Entity.ModelConfiguration.Conventions;
using System.Globalization;
using System.Linq;

namespace SQLite.CodeFirst.Convention
{
    /// <summary>
    /// Renames the indicies, generated by the 
    /// <see cref="ForeignKeyIndexConvention"/>-Convention, to match the scheme: "IX_{TableName}_{PropertyName}".
    /// This is necessary because in SQLite an index-name must be unique.
    /// Must be added right after the <see cref="ForeignKeyIndexConvention"/>-Convention.
    /// </summary>
    public class SqliteForeignKeyIndexConvention : IStoreModelConvention<AssociationType>
    {
        private const string IndexAnnotationName = "http://schemas.microsoft.com/ado/2013/11/edm/customannotation:Index";

        public virtual void Apply(AssociationType item, DbModel model)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            if (model == null)
            {
                throw new ArgumentNullException("model");
            }
            if (item.Constraint == null)
            {
                return;
            }

            foreach (var edmProperty in item.Constraint.ToProperties)
            {
                var annotation = GetAnnotation(edmProperty.MetadataProperties, IndexAnnotationName);
                if (annotation == null)
                {
                    continue;
                }

                // The original attribute is removed. The none-ForeignKeyIndicies will be remained and readded without any modification
                // and the foreignKeyIncidies will be readded with the correct name.
                edmProperty.RemoveAnnotation(IndexAnnotationName);

                // The schema for the automatically generated index name is "IX_{TableName}_{PropertyName}"
                var noneForeignKeyIndicies = annotation.Indexes.Where(index => index.Name != "IX_" + edmProperty.Name);
                IndexAnnotation newIndexAnnotation = new IndexAnnotation(noneForeignKeyIndicies);

                // The schema for a FK index, which is generated by the Entity Framework, is "IX_{PropertyName}"
                var property = edmProperty;
                var foreignKeyIndicies = annotation.Indexes.Where(index => index.Name == "IX_" + property.Name);
                foreach (var foreignKeyIndex in foreignKeyIndicies)
                {
                    var indexAttribute = new IndexAttribute(String.Format(CultureInfo.InvariantCulture, "IX_{0}_{1}", item.Constraint.ToRole.GetEntityType().GetTableName(), edmProperty.Name));
                    IndexAnnotation foreignKeyIndexAnnotation = new IndexAnnotation(indexAttribute);
                    newIndexAnnotation = (IndexAnnotation)newIndexAnnotation.MergeWith(foreignKeyIndexAnnotation);
                }

                edmProperty.AddAnnotation(IndexAnnotationName, newIndexAnnotation);
            }
        }

        private static IndexAnnotation GetAnnotation(IEnumerable<MetadataProperty> metadataProperties, string name)
        {
            foreach (MetadataProperty metadataProperty in metadataProperties)
            {
                if (metadataProperty.Name.Equals(name, StringComparison.Ordinal))
                {
                    return (IndexAnnotation)metadataProperty.Value;
                }
            }
            return null;
        }
    }
}